<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MD-Easy — Docs</title>
  <style>
    :root {
      --bg: #0f0f12;
      --surface: #18181c;
      --border: #2a2a30;
      --text: #e4e4e7;
      --muted: #71717a;
      --accent: #a78bfa;
      --accent-dim: #7c3aed;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "JetBrains Mono", "SF Mono", "Consolas", monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .layout {
      display: flex;
      flex: 1;
      min-height: 0;
    }
    .sidebar {
      width: 280px;
      min-width: 200px;
      background: var(--surface);
      border-right: 1px solid var(--border);
      overflow-y: auto;
      padding: 0.75rem 0;
    }
    .sidebar h2 {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin: 0 1rem 0.5rem;
      padding-top: 0.5rem;
    }
    .sidebar a {
      display: block;
      padding: 0.4rem 1rem;
      color: var(--text);
      text-decoration: none;
      font-size: 0.85rem;
      border-left: 2px solid transparent;
    }
    .sidebar a:hover { background: rgba(255,255,255,0.04); }
    .sidebar a.active {
      border-left-color: var(--accent);
      background: rgba(167,139,250,0.08);
    }
    .main {
      flex: 1;
      overflow: auto;
      padding: 1.5rem 2rem 3rem;
    }
    .main .doc {
      max-width: 72ch;
      line-height: 1.6;
    }
    .main .doc h1 { font-size: 1.75rem; margin-top: 0; }
    .main .doc h2 { font-size: 1.25rem; margin-top: 1.5rem; }
    .main .doc h3 { font-size: 1.05rem; }
    .main .doc pre, .main .doc code {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 4px;
    }
    .main .doc pre { padding: 1rem; overflow-x: auto; }
    .main .doc code { padding: 0.15em 0.4em; font-size: 0.9em; }
    .main .doc pre code { padding: 0; border: none; }
    .main .doc a { color: var(--accent); }
    .main .doc a:hover { text-decoration: underline; }
    .main .doc blockquote {
      border-left: 3px solid var(--accent-dim);
      margin: 1rem 0;
      padding-left: 1rem;
      color: var(--muted);
    }
    .welcome {
      color: var(--muted);
      padding: 2rem;
    }
    .welcome h1 { color: var(--text); font-size: 1.25rem; }
    .welcome p { margin: 0.5rem 0; }
    .refresh-status {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      font-size: 0.75rem;
      color: var(--muted);
    }
    .main .doc [id] { scroll-margin-top: 0.5rem; }
    .main .doc .mdeasy-highlight {
      background: rgba(167, 139, 250, 0.2);
      border-radius: 4px;
      animation: mdeasy-highlight-fade 2.5s ease-out forwards;
    }
    @keyframes mdeasy-highlight-fade {
      from { background: rgba(167, 139, 250, 0.35); }
      to { background: transparent; }
    }
  </style>
  <link id="theme-css" rel="stylesheet" href="/themes/default.css" />
</head>
<body>
  <div class="layout">
    <nav class="sidebar" id="sidebar">
      <h2>Docs</h2>
      <div id="file-list"></div>
    </nav>
    <main class="main" id="main">
      <div id="content"></div>
    </main>
  </div>
  <div class="refresh-status" id="refresh-status" aria-live="polite"></div>

  <script>
    const STORAGE_PREFIX = "mdeasy_scroll_";
    const MAIN = document.getElementById("main");
    const CONTENT = document.getElementById("content");
    const FILE_LIST = document.getElementById("file-list");
    const REFRESH_STATUS = document.getElementById("refresh-status");

    function getPathFromHash() {
      const h = window.location.hash.slice(1);
      const value = h.startsWith("/") ? h.slice(1) : h;
      const sharp = value.indexOf("#");
      const pathPart = sharp >= 0 ? value.slice(0, sharp) : value;
      return pathPart;
    }

    function getFragmentFromHash() {
      const h = window.location.hash.slice(1);
      const value = h.startsWith("/") ? h.slice(1) : h;
      const sharp = value.indexOf("#");
      if (sharp < 0) return null;
      const fragment = value.slice(sharp + 1);
      return fragment ? decodeURIComponent(fragment) : null;
    }

    function setHash(path, fragment) {
      const v = path ? "/" + path + (fragment ? "#" + encodeURIComponent(fragment) : "") : "";
      const current = getPathFromHash();
      const currentFrag = getFragmentFromHash();
      if (current !== path || (fragment || null) !== (currentFrag || null)) window.location.hash = v;
    }

    function scrollKey(path) { return STORAGE_PREFIX + path; }

    function saveScroll(path) {
      if (!path) return;
      try {
        sessionStorage.setItem(scrollKey(path), String(MAIN.scrollTop));
      } catch (_) {}
    }

    function restoreScroll(path) {
      if (!path) return;
      requestAnimationFrame(() => {
        try {
          const v = sessionStorage.getItem(scrollKey(path));
          if (v !== null) MAIN.scrollTop = parseInt(v, 10);
        } catch (_) {}
      });
    }

    let scrollSaveTimer;
    function scheduleScrollSave(path) {
      clearTimeout(scrollSaveTimer);
      scrollSaveTimer = setTimeout(() => saveScroll(path), 150);
    }

    let fileList = [];
    let currentPath = "";

    async function fetchFiles() {
      const r = await fetch("/api/files");
      if (!r.ok) throw new Error("files");
      const data = await r.json();
      fileList = data.files || [];
      return fileList;
    }

    function renderFileList(activePath) {
      FILE_LIST.innerHTML = "";
      fileList.forEach((path) => {
        const a = document.createElement("a");
        a.href = "#/" + path;
        a.textContent = path;
        if (path === activePath) a.classList.add("active");
        a.addEventListener("click", (e) => {
          e.preventDefault();
          setHash(path);
          loadDoc(path);
        });
        FILE_LIST.appendChild(a);
      });
    }

    function showWelcome() {
      const w = document.createElement("div");
      w.className = "welcome";
      const h1 = document.createElement("h1");
      h1.textContent = "MD-Easy";
      const p1 = document.createElement("p");
      p1.textContent = "Markdown docs with a refresh hook for AI-updated content.";
      const p2 = document.createElement("p");
      p2.appendChild(document.createTextNode("Pick a file from the sidebar, or call "));
      const code = document.createElement("code");
      code.textContent = "POST /refresh";
      p2.appendChild(code);
      p2.appendChild(document.createTextNode(" when docs change — your place is kept unless the current file is removed."));
      w.append(h1, p1, p2);
      CONTENT.replaceChildren(w);
    }

    function setDocHtml(html) {
      const wrap = document.createElement("div");
      wrap.className = "doc";
      wrap.append(document.createRange().createContextualFragment(html));
      CONTENT.replaceChildren(wrap);
    }

    let highlightTimer;
    function scrollToFragment(fragment, doHighlight) {
      if (!fragment || !CONTENT) return;
      const el = CONTENT.querySelector(".doc [id='" + CSS.escape(fragment) + "']");
      if (!el) return;
      el.scrollIntoView({ behavior: "smooth", block: "start" });
      if (doHighlight) {
        clearTimeout(highlightTimer);
        el.classList.add("mdeasy-highlight");
        highlightTimer = setTimeout(function () {
          el.classList.remove("mdeasy-highlight");
        }, 2500);
      }
    }

    async function loadDoc(path, fragment) {
      if (!path) {
        showWelcome();
        return;
      }
      try {
        const r = await fetch("/api/doc?path=" + encodeURIComponent(path));
        if (!r.ok) {
          if (r.status === 404) {
            setHash("");
            showWelcome();
            renderFileList("");
            showRefreshStatus("Document removed; returned to home.");
            return;
          }
          throw new Error(r.statusText);
        }
        const data = await r.json();
        setDocHtml(data.html);
        renderFileList(path);
        currentPath = path;
        if (fragment) {
          requestAnimationFrame(function () { scrollToFragment(fragment, true); });
        } else {
          restoreScroll(path);
        }
      } catch (e) {
        const w = document.createElement("div");
        w.className = "welcome";
        const p = document.createElement("p");
        p.textContent = "Failed to load: " + path;
        w.appendChild(p);
        CONTENT.replaceChildren(w);
        renderFileList(currentPath);
      }
    }

    function showRefreshStatus(msg) {
      REFRESH_STATUS.textContent = msg || "";
      if (msg) setTimeout(() => { REFRESH_STATUS.textContent = ""; }, 4000);
    }

    async function onRefresh() {
      const path = getPathFromHash();
      const fragment = getFragmentFromHash();
      const hadPath = path && path.length > 0;
      await fetchFiles();
      renderFileList(path);

      if (hadPath) {
        const stillExists = fileList.includes(path);
        if (stillExists) {
          await loadDoc(path, fragment);
          if (!fragment) restoreScroll(path);
          showRefreshStatus("Docs updated; view refreshed.");
        } else {
          setHash("");
          showWelcome();
          showRefreshStatus("Current doc was removed; returned to home.");
        }
      }
    }

    MAIN.addEventListener("scroll", () => {
      if (currentPath) scheduleScrollSave(currentPath);
    });

    window.addEventListener("hashchange", function () {
      const path = getPathFromHash();
      const fragment = getFragmentFromHash();
      if (!path) {
        loadDoc("");
        return;
      }
      if (path === currentPath && fragment !== null) {
        scrollToFragment(fragment, true);
        return;
      }
      loadDoc(path, fragment);
    });

    CONTENT.addEventListener("click", function (e) {
      const a = e.target.closest(".doc a[href^='#']");
      if (!a || !a.getAttribute("href")) return;
      const href = a.getAttribute("href");
      if (href.startsWith("#/")) return;
      const frag = href.slice(1);
      e.preventDefault();
      setHash(currentPath, frag);
      scrollToFragment(frag, true);
    });

    (function initSSE() {
      const es = new EventSource("/api/events");
      es.onmessage = function (ev) {
        try {
          const d = JSON.parse(ev.data);
          if (d.version == null) return;
          if (d.navigate) {
            setHash(d.navigate.path, d.navigate.fragment || null);
            (async function () {
              await fetchFiles();
              renderFileList(d.navigate.path);
              if (fileList.includes(d.navigate.path)) {
                await loadDoc(d.navigate.path, d.navigate.highlight !== false ? (d.navigate.fragment || null) : null);
              }
              showRefreshStatus("Docs updated; view refreshed.");
            })();
          } else {
            onRefresh();
          }
        } catch (_) {}
      };
      es.onerror = function () { es.close(); setTimeout(initSSE, 5000); };
    })();

    function applyTheme(theme) {
      const link = document.getElementById("theme-css");
      if (link && theme) link.href = "/themes/" + theme + ".css";
    }

    var VALID_THEMES = ["default", "homebrew", "solarized-light", "solarized-dark"];

    (async function init() {
      var themeParam = new URLSearchParams(window.location.search).get("theme");
      if (themeParam && VALID_THEMES.indexOf(themeParam) !== -1) {
        applyTheme(themeParam);
      } else {
        try {
          const r = await fetch("/api/config");
          if (r.ok) {
            const cfg = await r.json();
            if (cfg.theme) applyTheme(cfg.theme);
          }
        } catch (_) {}
      }
      await fetchFiles();
      const path = getPathFromHash();
      const fragment = getFragmentFromHash();
      if (path && fileList.includes(path)) {
        await loadDoc(path, fragment);
      } else {
        if (path) setHash("");
        showWelcome();
        renderFileList("");
      }
    })();
  </script>
</body>
</html>
